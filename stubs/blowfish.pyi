from typing import Callable, Iterable, Iterator, Sequence, Union
from typing_extensions import Literal

class Cipher:
    def __init__(
        self,
        key: bytes,
        byte_order: Union[Literal["big"], Literal["little"]] = ...,
        P_array: Sequence[int] = ...,
        S_boxes: Sequence[Sequence[int]] = ...,
    ) -> None: ...
    def encrypt_block(self, block: bytes) -> bytes: ...
    def decrypt_block(self, block: bytes) -> bytes: ...
    def encrypt_ecb(self, data: bytes) -> Iterator[bytes]: ...
    def decrypt_ecb(self, data: bytes) -> Iterator[bytes]: ...
    def encrypt_ecb_cts(self, data: bytes) -> Iterator[bytes]: ...
    def decrypt_ecb_cts(self, data: bytes) -> Iterator[bytes]: ...
    def encrypt_cbc(self, data: bytes, init_vector: bytes) -> Iterator[bytes]: ...
    def decrypt_cbc(self, data: bytes, init_vector: bytes) -> Iterator[bytes]: ...
    def encrypt_cbc_cts(self, data: bytes, init_vector: bytes) -> Iterator[bytes]: ...
    def decrypt_cbc_cts(self, data: bytes, init_vector: bytes) -> Iterator[bytes]: ...
    def encrypt_pcbc(self, data: bytes, init_vector: bytes) -> Iterator[bytes]: ...
    def decrypt_pcbc(self, data: bytes, init_vector: bytes) -> Iterator[bytes]: ...
    def encrypt_cfb(self, data: bytes, init_vector: bytes) -> Iterator[bytes]: ...
    def decrypt_cfb(self, data: bytes, init_vector: bytes) -> Iterator[bytes]: ...
    def encrypt_ofb(self, data: bytes, init_vector: bytes) -> Iterator[bytes]: ...
    def decrypt_ofb(self, data: bytes, init_vector: bytes) -> Iterator[bytes]: ...
    def encrypt_ctr(self, data: bytes, counter: Iterable[int]) -> Iterator[bytes]: ...
    def decrypt_ctr(self, data: bytes, counter: Iterable[int]) -> Iterator[bytes]: ...

def ctr_counter(
    nonce: int, f: Callable[[int, int], int], start: int = ...
) -> Iterator[int]: ...
